"""
Registry Manager
Handles agent registration with the Nasiko backend.
"""

import json
import logging
from pathlib import Path
import os

import requests

from config import NASIKO_API_URL, AGENTS_DIRECTORY
from docker_utils import get_kong_agent_url

logger = logging.getLogger(__name__)


class RegistryManager:
    """Manages agent registry operations"""

    def __init__(self):
        self.agents_dir = Path(AGENTS_DIRECTORY)

    def update_agent_registry(self, agent_folder_name, action="upsert", owner_id=None):
        """Update agent registry in Nasiko backend

        Returns:
            dict: {
                'success': bool,
                'url': str,
                'registry_id': str or None
            }
        """
        # Look for AgentCard.json (generated by agentcard_generator)
        agentcard_path = self.agents_dir / agent_folder_name / "AgentCard.json"

        if not agentcard_path.exists():
            logger.warning(
                f"No AgentCard.json found for {agent_folder_name}, skipping registry update..."
            )
            return {"success": False, "url": None, "registry_id": None}

        try:
            with open(agentcard_path, "r") as f:
                agentcard_data = json.load(f)

            # Get the Kong gateway URL for the agent (external access)
            # Always use folder name for Kong URL (matches container name)
            url = get_kong_agent_url(agent_folder_name)
            logger.info(f"Agent {agent_folder_name} Kong URL: {url}")

            # Build registry data from AgentCard format
            registry_data = agentcard_data.copy()

            # Update url to use Kong gateway
            registry_data["url"] = url

            # Always set id to folder name (used for upsert identification and Kong routing)
            registry_data["id"] = agent_folder_name
            
            # Set owner_id if provided
            if owner_id:
                registry_data["owner_id"] = owner_id
                logger.info(f"Setting owner_id for {agent_folder_name}: {owner_id}")

            logger.info(
                f"Registry data for {agent_folder_name}: id = {registry_data.get('id')}, name = {registry_data.get('name')}, Kong URL = {url}, owner_id = {registry_data.get('owner_id')}"
            )

            if action == "upsert":
                result = self._upsert_agent(agent_folder_name, registry_data)
                
                # If registry upsert was successful and we have owner_id, create agent permissions
                if result.get("success", False) and owner_id:
                    permission_success = self._create_agent_permissions(agent_folder_name, owner_id)
                    if not permission_success:
                        logger.warning(f"Registry upserted but permission creation failed for agent {agent_folder_name}")
                
                return {
                    "success": result.get("success", False),
                    "url": url,
                    "registry_id": result.get("registry_id"),
                }
            elif action == "delete":
                success = self._delete_agent(agent_folder_name)
                return {"success": success, "url": url, "registry_id": None}
            else:
                logger.error(f"Unknown action: {action}")
                return {"success": False, "url": url, "registry_id": None}

        except Exception as e:
            logger.error(f"Error updating registry for {agent_folder_name}: {str(e)}")
            return {"success": False, "url": None, "registry_id": None}

    def _upsert_agent(self, agent_folder_name, registry_data):
        """Upsert agent in registry - update if exists, create if not

        Returns:
            dict: {
                'success': bool,
                'registry_id': str or None
            }
        """
        try:
            url = f"{NASIKO_API_URL}/api/v1/registry/agent/{agent_folder_name}"

            # Log the data being sent for debugging
            logger.info(
                f"Upserting agent {agent_folder_name} with data: {json.dumps(registry_data, indent=2)}"
            )

            response = requests.put(url, json=registry_data, timeout=30)

            if response.status_code == 200:
                logger.info(f"Successfully upserted {agent_folder_name} in registry")

                # Try to extract registry ID from response
                try:
                    response_data = response.json()
                    registry_id = response_data.get("id") or response_data.get("_id")
                    if registry_id:
                        logger.info(
                            f"Registry ID for {agent_folder_name}: {registry_id}"
                        )
                    return {"success": True, "registry_id": registry_id}
                except Exception as parse_error:
                    logger.warning(
                        f"Could not parse response for {agent_folder_name}: {parse_error}"
                    )
                    return {"success": True, "registry_id": None}
            else:
                logger.error(
                    f"Failed to upsert {agent_folder_name}: {response.status_code} - {response.text}"
                )
                return {"success": False, "registry_id": None}

        except requests.exceptions.RequestException as e:
            logger.error(f"Network error upserting {agent_folder_name}: {e}")
            return {"success": False, "registry_id": None}

    def _delete_agent(self, agent_folder_name):
        """Delete agent from registry"""
        try:
            url = f"{NASIKO_API_URL}/api/v1/registry/{agent_folder_name}"
            response = requests.delete(url, timeout=30)

            if response.status_code == 200:
                logger.info(f"Successfully deleted {agent_folder_name} from registry")
                return True
            else:
                logger.error(
                    f"Failed to delete {agent_folder_name}: {response.status_code} - {response.text}"
                )
                return False

        except requests.exceptions.RequestException as e:
            logger.error(f"Network error deleting {agent_folder_name}: {e}")
            return False

    def _create_agent_permissions(self, agent_id, owner_id):
        """Create agent permissions in the auth service"""
        try:
            # Use same auth service URL as superuser manager
            auth_service_url = os.getenv("AUTH_SERVICE_URL", "http://localhost:8082")
            url = f"{auth_service_url}/auth/agents/{agent_id}/permissions"
            
            logger.info(f"Creating permissions for agent {agent_id} with owner {owner_id}")
            
            response = requests.post(url, params={"owner_id": owner_id}, timeout=30)
            
            if response.status_code in [200, 201]:
                logger.info(f"Successfully created permissions for agent {agent_id}")
                return True
            else:
                logger.error(f"Failed to create permissions for agent {agent_id}: {response.status_code} - {response.text}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"Network error creating permissions for agent {agent_id}: {e}")
            return False
        except Exception as e:
            logger.error(f"Error creating permissions for agent {agent_id}: {e}")
            return False

    def get_agent_api_key(self, agent_name, langtrace_host="http://localhost:3000"):
        """Get API key for a specific agent from LangTrace"""
        try:
            url = f"{langtrace_host}/api/v1/agents"
            params = {"agent_name": agent_name}

            logger.info(f"Retrieving API key for agent: {agent_name}")
            response = requests.get(url, params=params, timeout=30)

            if response.status_code == 200:
                data = response.json()
                api_key = data.get("api_key")
                project_id = data.get("project_id")
                logger.info(
                    f"Successfully retrieved API key for {agent_name} (project: {project_id})"
                )
                return api_key
            elif response.status_code == 400:
                logger.warning(
                    f"Agent {agent_name} not found in LangTrace: {response.json().get('error', 'Unknown error')}"
                )
                return None
            else:
                logger.error(
                    f"Failed to retrieve API key for {agent_name}: {response.status_code} - {response.text}"
                )
                return None

        except requests.exceptions.RequestException as e:
            logger.error(f"Network error retrieving API key for {agent_name}: {e}")
            return None
        except Exception as e:
            logger.error(f"Error retrieving API key for {agent_name}: {e}")
            return None

    def create_or_get_agent(self, agent_name, langtrace_host="http://localhost:3000"):
        """Create or get agent using LangTrace V1 API (auto-creates project and API key)"""
        try:
            # Use the new V1 agents endpoint for creation/retrieval
            url = f"{langtrace_host}/api/v1/agents"

            logger.info(f"Creating/retrieving agent: {agent_name}")

            # POST request creates agent if it doesn't exist, returns existing if it does
            response = requests.post(url, json={"agent_name": agent_name}, timeout=30)

            if response.status_code == 200:
                data = response.json()
                api_key = data.get("api_key")
                project_id = data.get("project_id")
                agent_name_response = data.get("agent_name")

                logger.info(
                    f"Successfully created/retrieved agent {agent_name_response}"
                )
                logger.info(f"Project ID: {project_id}, API Key: {api_key[:20]}...")

                return {
                    "success": True,
                    "agent_name": agent_name_response,
                    "project_id": project_id,
                    "api_key": api_key,
                }
            else:
                logger.error(
                    f"Failed to create/retrieve agent {agent_name}: {response.status_code} - {response.text}"
                )
                return {"success": False, "error": response.text}

        except requests.exceptions.RequestException as e:
            logger.error(f"Network error creating/retrieving agent {agent_name}: {e}")
            return {"success": False, "error": str(e)}
        except Exception as e:
            logger.error(f"Error creating/retrieving agent {agent_name}: {e}")
            return {"success": False, "error": str(e)}

    def store_agent_credentials(
        self, agent_name, api_key, project_id, additional_info=None
    ):
        """Store agent LangTrace credentials in Nasiko registry for later retrieval"""
        try:
            # Update the agent registry with LangTrace credentials
            url = f"{NASIKO_API_URL}/api/v1/update-agent-credentials/{agent_name}"

            credentials_data = {
                "langtrace_api_key": api_key,
                "langtrace_project_id": project_id,
            }

            if additional_info:
                credentials_data.update(additional_info)

            logger.info(f"Storing credentials for agent {agent_name}")
            response = requests.put(url, json=credentials_data, timeout=30)

            if response.status_code == 200:
                logger.info(f"Successfully stored credentials for {agent_name}")
                return True
            else:
                logger.error(
                    f"Failed to store credentials for {agent_name}: {response.status_code} - {response.text}"
                )
                return False

        except requests.exceptions.RequestException as e:
            logger.error(f"Network error storing credentials for {agent_name}: {e}")
            return False
        except Exception as e:
            logger.error(f"Error storing credentials for {agent_name}: {e}")
            return False
